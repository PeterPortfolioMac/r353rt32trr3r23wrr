<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>360° Panorama Viewer</title>

  <style>
    :root{
      --bg0:#05070b;
      --bg1:#071620;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.09);
      --text:#eaf2ff;
      --muted:rgba(234,242,255,.72);
      --muted2:rgba(234,242,255,.55);
      --accent:#7c5cff;
      --accent2:#49d3ff;
      --danger:#ff4d4d;
      --ok:#3ddc97;
      --shadow: 0 20px 80px rgba(0,0,0,.55);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(124,92,255,.25), transparent 55%),
        radial-gradient(1000px 600px at 90% 10%, rgba(73,211,255,.18), transparent 55%),
        radial-gradient(900px 500px at 50% 100%, rgba(61,220,151,.10), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
    }
    .wrap{
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px 18px 28px;
    }
    header{
      display:flex;
      gap:16px;
      align-items:flex-start;
      justify-content:space-between;
      margin-bottom:14px;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{
      margin:0;
      font-size: clamp(20px, 2.2vw, 30px);
      letter-spacing:.2px;
    }
    .subtitle{
      color:var(--muted);
      line-height:1.35;
      font-size: 14px;
      max-width: 820px;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .controls{
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .file{
      flex: 1 1 320px;
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.24);
      border:1px solid rgba(255,255,255,.10);
      min-width: 280px;
    }
    .file label{
      font-size:13px;
      color:var(--muted);
      white-space:nowrap;
    }
    .file input[type="file"]{
      width:100%;
      color:var(--muted2);
    }

    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.07);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      font-weight:600;
      font-size: 13px;
      line-height:1;
      white-space:nowrap;
    }
    .btn:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.18); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(135deg, rgba(124,92,255,.95), rgba(73,211,255,.65));
      border-color: rgba(124,92,255,.35);
    }
    .btn.primary:hover{ filter: brightness(1.03); }
    .btn.danger{
      background: rgba(255,77,77,.14);
      border-color: rgba(255,77,77,.28);
      color: #ffd7d7;
    }
    .status{
      width:100%;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      font-size: 13px;
      color: var(--muted);
    }
    .status strong{ color: var(--text); }

    .viewer{
      margin-top: 14px;
      height: min(70vh, 640px);
      border-radius: var(--radius);
      overflow:hidden;
      position:relative;
      background: #000;
      border: 1px solid rgba(255,255,255,.10);
    }
    canvas{ display:block; width:100%; height:100%; }

    .hud{
      position:absolute;
      left: 12px;
      top: 12px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      pointer-events:none;
    }
    .pill{
      font-size: 12px;
      color: rgba(255,255,255,.85);
      background: rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.12);
      padding: 6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .help{
      position:absolute;
      left: 12px;
      bottom: 12px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      pointer-events:none;
    }
    .hint{
      font-size: 12px;
      color: rgba(255,255,255,.78);
      background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      padding: 6px 10px;
      border-radius: 999px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    @media (max-width: 720px){
      header{ flex-direction:column; align-items:flex-start; }
      .viewer{ height: min(70vh, 520px); }
      .btn{ padding: 10px 11px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>360° Panorama Viewer (drag cu mouse / touch)</h1>
        <div class="subtitle">
          Încarcă o panoramă equirectangulară (raport ~2:1).
          Dacă imaginea e foarte mare (ex. 11968×5984), viewer-ul o micșorează automat la limita GPU pentru a evita ecranul negru.
          <br>
          <b>Pe file://</b> merge și butonul „Încarcă pano1.jpg”, dacă fișierul există lângă <code>index.html</code>.
          Pe <b>github.io</b> pune fișierele în repo și folosește căi relative / URL public.
        </div>
      </div>
    </header>

    <div class="panel controls">
      <div class="row">
        <div class="file">
          <label for="fileInput">Alege imagine 360…</label>
          <input id="fileInput" type="file" accept="image/*" />
        </div>

        <button class="btn primary" id="loadDefaultBtn">Încarcă pano1.jpg (din folder)</button>

        <button class="btn" id="resetBtn">Reset view</button>
        <button class="btn" id="autoBtn">Auto-rotate</button>
        <button class="btn danger" id="stopBtn">Stop</button>
      </div>

      <div class="row">
        <div class="file">
          <label for="jsonInput">JSON cu cale/URL…</label>
          <input id="jsonInput" type="file" accept="application/json,.json" />
        </div>
        <button class="btn" id="loadJsonBtn">Încarcă JSON</button>
        <button class="btn" id="loadJsonDefaultBtn">Încarcă config.json (din folder)</button>
      </div>

      <div class="row">
        <div class="status" id="status">Status: aștept o imagine…</div>
      </div>
    </div>

    <div class="viewer" id="viewer">
      <div class="hud">
        <div class="pill" id="gpuInfo">MAX_TEXTURE_SIZE: …</div>
        <div class="pill" id="imgInfo">Imagine: —</div>
      </div>

      <div class="help">
        <div class="hint">Drag: rotire</div>
        <div class="hint">Wheel/pinch: zoom</div>
        <div class="hint">Double click: reset</div>
      </div>
    </div>
  </div>

  <!-- Three.js (CDN). Pentru github.io e perfect. -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    // ====== Setup Three.js ======
    const viewerEl = document.getElementById('viewer');
    const statusEl = document.getElementById('status');
    const gpuInfoEl = document.getElementById('gpuInfo');
    const imgInfoEl = document.getElementById('imgInfo');

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, 1, 0.1, 2000);
    camera.position.set(0, 0, 0.1);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    viewerEl.appendChild(renderer.domElement);

    // --- GPU limits ---
    const gl = renderer.getContext();
    const MAX_TEX = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    gpuInfoEl.textContent = `MAX_TEXTURE_SIZE: ${MAX_TEX}`;

    // Sphere (inside-out)
    const geometry = new THREE.SphereGeometry(500, 64, 32);
    geometry.scale(-1, 1, 1);

    let material = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    // ====== Controls state ======
    let isUserInteracting = false;
    let lon = 0, lat = 0;
    let phi = 0, theta = 0;
    let onPointerDownPointerX = 0, onPointerDownPointerY = 0;
    let onPointerDownLon = 0, onPointerDownLat = 0;

    let fov = 70;
    const fovMin = 35;
    const fovMax = 95;

    let autoRotate = false;
    let autoRotateSpeed = 0.06; // deg per frame-ish

    function setStatus(msg, type="info"){
      // type: info | ok | err
      const color = type === "ok" ? "var(--ok)" : type === "err" ? "var(--danger)" : "var(--muted)";
      statusEl.innerHTML = `<strong>Status:</strong> <span style="color:${color}">${escapeHtml(msg)}</span>`;
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }

    function resize(){
      const w = viewerEl.clientWidth;
      const h = viewerEl.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h, false);
    }
    window.addEventListener('resize', resize);
    resize();

    // ====== Interaction ======
    viewerEl.addEventListener('pointerdown', (e)=>{
      isUserInteracting = true;
      viewerEl.setPointerCapture?.(e.pointerId);
      onPointerDownPointerX = e.clientX;
      onPointerDownPointerY = e.clientY;
      onPointerDownLon = lon;
      onPointerDownLat = lat;
    });

    viewerEl.addEventListener('pointermove', (e)=>{
      if(!isUserInteracting) return;
      const dx = (e.clientX - onPointerDownPointerX);
      const dy = (e.clientY - onPointerDownPointerY);
      lon = onPointerDownLon - dx * 0.1;
      lat = onPointerDownLat + dy * 0.1;
    });

    viewerEl.addEventListener('pointerup', ()=>{
      isUserInteracting = false;
    });

    // wheel zoom
    viewerEl.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const delta = Math.sign(e.deltaY);
      fov = THREE.MathUtils.clamp(fov + delta * 2.4, fovMin, fovMax);
      camera.fov = fov;
      camera.updateProjectionMatrix();
    }, { passive:false });

    // double click reset
    viewerEl.addEventListener('dblclick', ()=>{
      resetView();
    });

    // touch pinch zoom
    let lastDist = null;
    viewerEl.addEventListener('touchmove', (e)=>{
      if(e.touches && e.touches.length === 2){
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);
        if(lastDist !== null){
          const dd = dist - lastDist;
          fov = THREE.MathUtils.clamp(fov - dd * 0.03, fovMin, fovMax);
          camera.fov = fov;
          camera.updateProjectionMatrix();
        }
        lastDist = dist;
      }
    }, { passive:false });

    viewerEl.addEventListener('touchend', ()=>{
      lastDist = null;
    });

    function resetView(){
      lon = 0; lat = 0;
      fov = 70;
      camera.fov = fov;
      camera.updateProjectionMatrix();
      setStatus("View reset.", "ok");
    }

    // ====== Image loading ======

    async function imageFromFile(file){
      return new Promise((resolve, reject)=>{
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = ()=>{
          URL.revokeObjectURL(url);
          resolve(img);
        };
        img.onerror = ()=>reject(new Error("Nu pot citi imaginea (fișier invalid sau blocat)."));
        img.src = url;
      });
    }

    async function imageFromURL(url){
      // FIX: merge și pe file:// dacă fișierul este lângă index.html.
      // Pentru http(s) păstrăm comportamentul standard.
      return new Promise((resolve, reject)=>{
        const img = new Image();

        const isHttp = location.protocol === "http:" || location.protocol === "https:";
        if(isHttp){
          // dacă tragi imagini de pe alt domeniu și vrei canvas safe, ai nevoie de CORS ok.
          img.crossOrigin = "anonymous";
        }

        img.onload = ()=> resolve(img);
        img.onerror = ()=> reject(new Error(`Nu pot încărca imaginea: ${url}`));

        // Important: fă URL absolut (evită edge-case-uri pe file://)
        const absolute = new URL(url, window.location.href).href;
        img.src = absolute;
      });
    }

    function calcDownscaleSize(w, h){
      // 1) respectă limita GPU
      // 2) safe cap (multe device-uri dau rateuri cu texturi enorme)
      const SAFE_CAP = Math.min(8192, MAX_TEX);
      const maxSide = Math.min(MAX_TEX, SAFE_CAP);

      const scale = Math.min(1, maxSide / Math.max(w, h));
      return {
        w: Math.max(1, Math.round(w * scale)),
        h: Math.max(1, Math.round(h * scale)),
        scale
      };
    }

    function downscaleToCanvas(img){
      const {w, h, scale} = calcDownscaleSize(img.naturalWidth || img.width, img.naturalHeight || img.height);
      const needs = scale < 1;

      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha:false });

      // drawImage downscale
      ctx.drawImage(img, 0, 0, w, h);

      return { canvas, w, h, needs };
    }

    async function loadPanoramaFromImage(img, label="(imagine)"){
      const srcW = img.naturalWidth || img.width;
      const srcH = img.naturalHeight || img.height;

      if(!srcW || !srcH){
        setStatus("Imagine invalidă (0×0).", "err");
        return;
      }

      const {canvas, w, h, needs} = downscaleToCanvas(img);

      // Texture
      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.needsUpdate = true;

      // dispose old material/texture
      if(material?.map){
        material.map.dispose();
      }
      material.dispose?.();

      material = new THREE.MeshBasicMaterial({ map: tex });
      sphere.material = material;

      const info = needs
        ? `${label} | downscale ${srcW}×${srcH} → ${w}×${h} (${w}×${h})`
        : `${label} | size ${srcW}×${srcH}`;

      imgInfoEl.textContent = `Imagine: ${info}`;
      setStatus(`Încărcat: ${label}`, "ok");
    }

    // ====== JSON loading ======
    function extractPanoUrlFromJson(obj){
      if(!obj || typeof obj !== "object") return null;
      // Acceptă mai multe chei
      return obj.pano || obj.url || obj.image || obj.src || null;
    }

    async function readJsonFile(file){
      const text = await file.text();
      return JSON.parse(text);
    }

    async function loadFromJsonURL(jsonUrl){
      // JSON-ul trebuie să fie accesibil (same-origin pe github pages sau CORS ok).
      const abs = new URL(jsonUrl, window.location.href).href;
      const res = await fetch(abs, { cache: "no-store" });
      if(!res.ok) throw new Error(`Nu pot încărca JSON (${res.status}).`);
      const data = await res.json();
      const pano = extractPanoUrlFromJson(data);
      if(!pano) throw new Error("JSON invalid. Exemplu: {\"pano\":\"pano1.jpg\"}");
      const img = await imageFromURL(pano);
      await loadPanoramaFromImage(img, pano);
    }

    // ====== UI wiring ======

    // manual image upload
    document.getElementById('fileInput').addEventListener('change', async (e)=>{
      const file = e.target.files?.[0];
      if(!file) return;
      try{
        setStatus("Încarc imaginea aleasă…");
        const img = await imageFromFile(file);
        await loadPanoramaFromImage(img, file.name);
      }catch(err){
        console.error(err);
        setStatus(err.message || "Eroare la încărcare.", "err");
      }
    });

    // default pano1.jpg from folder
    document.getElementById('loadDefaultBtn').addEventListener('click', async ()=>{
      setStatus("Încerc să încarc pano1.jpg din același folder…");
      try{
        const img = await imageFromURL('pano1.jpg');
        await loadPanoramaFromImage(img, 'pano1.jpg');
      }catch(err){
        console.error(err);
        setStatus(
          "Nu am găsit/putut încărca pano1.jpg. Verifică dacă e lângă index.html (pe github.io trebuie să fie în repo).",
          "err"
        );
      }
    });

    // JSON upload
    document.getElementById('loadJsonBtn').addEventListener('click', async ()=>{
      const input = document.getElementById('jsonInput');
      const file = input.files?.[0];
      if(!file){
        setStatus("Alege un fișier JSON mai întâi.", "err");
        return;
      }
      try{
        setStatus("Citesc JSON…");
        const data = await readJsonFile(file);
        const pano = extractPanoUrlFromJson(data);
        if(!pano) throw new Error("JSON invalid. Exemplu: {\"pano\":\"pano1.jpg\"}");
        setStatus(`Încarc panorama din JSON: ${pano} …`);
        const img = await imageFromURL(pano);
        await loadPanoramaFromImage(img, pano);
      }catch(err){
        console.error(err);
        setStatus(err.message || "Eroare la încărcarea JSON.", "err");
      }
    });

    // default config.json from folder (pentru github.io ideal)
    document.getElementById('loadJsonDefaultBtn').addEventListener('click', async ()=>{
      try{
        setStatus("Încerc să încarc config.json din folder…");
        await loadFromJsonURL('config.json');
        setStatus("Încărcat din config.json.", "ok");
      }catch(err){
        console.error(err);
        setStatus("Nu pot încărca config.json. Verifică dacă există lângă index.html și rulezi din http(s).", "err");
      }
    });

    // buttons
    document.getElementById('resetBtn').addEventListener('click', resetView);

    document.getElementById('autoBtn').addEventListener('click', ()=>{
      autoRotate = true;
      setStatus("Auto-rotate: ON", "ok");
    });

    document.getElementById('stopBtn').addEventListener('click', ()=>{
      autoRotate = false;
      setStatus("Auto-rotate: OFF", "ok");
    });

    // ====== Render loop ======
    function animate(){
      requestAnimationFrame(animate);

      if(autoRotate && !isUserInteracting){
        lon += autoRotateSpeed;
      }

      lat = Math.max(-85, Math.min(85, lat));
      phi = THREE.MathUtils.degToRad(90 - lat);
      theta = THREE.MathUtils.degToRad(lon);

      const x = 500 * Math.sin(phi) * Math.cos(theta);
      const y = 500 * Math.cos(phi);
      const z = 500 * Math.sin(phi) * Math.sin(theta);

      camera.lookAt(x, y, z);
      renderer.render(scene, camera);
    }
    animate();

    // ====== Auto-load support ======
    // 1) Dacă există ?pano=... sau ?json=... în URL, încarcă automat (perfect pentru github.io)
    // Ex: https://user.github.io/site/index.html?pano=pano1.jpg
    // Ex: https://user.github.io/site/index.html?json=config.json
    (async function bootAuto(){
      try{
        const q = new URLSearchParams(location.search);
        const json = q.get("json");
        const pano = q.get("pano");
        if(json){
          setStatus(`Auto: încarc JSON: ${json} …`);
          await loadFromJsonURL(json);
          return;
        }
        if(pano){
          setStatus(`Auto: încarc pano: ${pano} …`);
          const img = await imageFromURL(pano);
          await loadPanoramaFromImage(img, pano);
          return;
        }

        // 2) Dacă nu e parametrizat, încearcă pano1.jpg implicit (merge și pe file:// dacă există local)
        // (Dacă nu există, doar afișăm "aștept o imagine…", fără să stricăm restul.)
        try{
          const img = await imageFromURL('pano1.jpg');
          await loadPanoramaFromImage(img, 'pano1.jpg');
          setStatus("Încărcat automat pano1.jpg ✅", "ok");
        }catch(_){
          setStatus("Aștept o imagine… (poți încărca manual sau folosi pano1.jpg/config.json)", "info");
        }
      }catch(err){
        console.error(err);
        setStatus("Auto-load a eșuat. Încarcă manual o imagine.", "err");
      }
    })();
  </script>
</body>
</html>
